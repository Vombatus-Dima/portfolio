/**
  ******************************************************************************
  * @file    uart_control.h
  * @author  Trembach Dmitry
  * @version V2.5.0
  * @date    02-02-2019
  * @brief   Инициализация драйвера для управление UART в режимах RS485/RS422
  *
  *
  *   RS должен работать в двух режимах RS485 и RS422
  *    Контроль полярности
  *    Изменение скорости с диапазоне 1500 - 900 000 бод/сек 
  *
  *    При передаче по RS422 интервал между пакета 30 бод мин
  *    Режим работы - автомат состояний
  *    Переключение режима работы в прерываниях 
  *    Статистика по следующим параметрам:
  *    
  *   Статус подключения
  *   Физический адрес ВРМ к которому подключен
  *   Счётчик ошибок последовательности по приёму
  *   Счётчик ошибок CRC по приёму
  *   Счётчик ошибок переполнения буфера DMA по передаче
  *   Счётчик поиска полярности, увеличивается, если произошёл 
  *   разрыв связи и начался процесс поиска полярности
  *   % загрузки — текущий  (за время *) 
  *   % загрузки — минимальный (за время *)
  *   % загрузки — максимальный  (за время *)
  *
  *    
  *
  *
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2015 DataExpress</center></h2>
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __UART_CONTROL_H
#define __UART_CONTROL_H

/* Includes ------------------------------------------------------------------*/
#include "stm32f4xx.h"
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "Core.h"
#include "board.h" 
#include "main.h" 
    
#if RS_GATE_ENABLE == 1   
    
//#define TEST_PIN_RS_ENABLE (1)

#if UDP_LOGGER == 1            
#include "udp_log.h"
#endif
    
/*======================== Команды управления аппаратным таймером =======================*/
#define stop_hard_timer(TIMXX)             TIMXX->CR1 &= (uint16_t)~TIM_CR1_CEN                                                    /* Отключение таймера                     */ 
#define start_hard_timer(TIMXX)            TIMXX->CR1 |= TIM_CR1_CEN                                                               /* Включение таймера                      */  
#define set_hard_timer(TIMXX,a)            TIMXX->CNT = 0xFFFF - a                                                                 /* Установка таймера на заданный интервал */  
#define update_hard_timer(TIMXX,a)         TIMXX->CR1 &= (uint16_t)~TIM_CR1_CEN;TIMXX->CNT = 0xFFFF - a;TIMXX->CR1 |= TIM_CR1_CEN  /* Установка таймера на заданный интервал */     
/*=======================================================================================*/

/*======================== Команды управления аппаратным выводом =======================*/
#define set_pin( port_gpio, pin_gpio )     port_gpio->BSRRL = pin_gpio   
#define reset_pin( port_gpio, pin_gpio )   port_gpio->BSRRH = pin_gpio    
#define get_pin( port_gpio, pin_gpio )     (port_gpio->IDR) & pin_gpio
/*=======================================================================================*/

    
#define CONTROL_POLAR_TIME           (2000)  /* Период таймера коонтроля полярности в тиках OS   */
                                             /* Ожидание приема пакета в течении 1 сек           */
                                             /* Если не принят ни один пакет - смена полярности  */
    
#define CONTROL_POLAR_TIME_POWER    (60000)  /* Период таймера коонтроля полярности в тиках OS   */
                                             /* Ожидание приема пакета в течении 1 сек           */
                                             /* Если не принят ни один пакет - смена полярности  */    
    
    
#define CONTROL_BOX_TX_MAXTIME_WAIT  (300)   /* Период таймера коонтроля передачи в тиках OS     */
                                             /* RS422 маркер/данные не реже 300 ms               */
                                             /* Если не передан ни один пакет - отправляем маркер*/
    
#define SIZE_LITTLE_TIME             (1000)  // Величина малого интервала диагностики в млсек     
    
//================= Определение индикации режимов работы =======================
// Автомат работы 
typedef enum 
{
  RS_RX_NONE_STATE = 0,        /* Прием отключен  */
  RS_RX_WAIT_RECEIVE,          /* Ожидание приема */ 
  RS_RX_RECEIVE                /* Прием данных    */
}RS_RX_FST_t;	
    
typedef enum 
{
  RS_TX_NONE_STATE = 0,        /* Передача отключена  */
  RS_TX_WAIT_SEND,             /* Ожидание передачи   */ 
  RS_TX_SEND,                  /* Передача            */
  RS_TX_WAIT_SEND_COMPLT,      /* Ожидание завершения передачи */
  RS_TX_BLOK_SEND              /* Блокировка передачи */
}RS_TX_FST_t;
   
// Автомат работы 
typedef enum 
{
  RS485_NONE_STATE = 0,        //выключено
  RS485_RECEIVE,               //прием	
  RS485_SEND,                  //передача
  RS485_SWITH_REC_SEND,        //переключение прием передача
  RS485_SWITH_SEND_REC,	       //переключение передача прием 
  RS485_WAIT_RECEIVE           //ожидание приема
}RS485_FST_t;	

//Режим работы 
typedef enum 
{
  SET_RS485_M = 0,     /* режим мастер RS485        */
  SET_RS485_S = 1,     /* режим подчиненный RS485   */
  SET_RS422 = 2,       /* режим RS422               */
  SET_RS485_P = 3,     /* режим для управления источниками питания */
}type_set_connect_t;

//Тип соединения 
typedef enum 
{
  CON_RS485_M = 0,    /* подключение по RS485 как мастер        */
  CON_RS485_S = 1,    /* подключение по RS485 подчиненный       */
  CON_RS422 = 2,      /* подключение по RS422   */
}type_connect_t;

//Аппаратная установка режима работы  
typedef enum 
{
  HARD_MODE_EMPTY = 0,    /* нет аппаратной установки */ 
  HARD_MODE_RS485 = 1,    /* режим RS485              */
  HARD_MODE_RS422 = 2,    /* режим RS422              */
}type_hard_mode_t;

//Режимы работы маркера 
typedef enum 
{
  MARKER_ENA_TRANS = 0,    /* Включена отправка маркеров  */
  MARKER_DIS_TRANS         /* Отключена отправка маркеров */
}marker_mode_t;

//Тип полярности подключения 
typedef enum 
{
  POLAR_LO = 0,    // полярность подключения по RS
  POLAR_HI         // полярность подключения по RS
}type_polar_t;

//Статус подключения 
typedef enum 
{
  CON_OFF = 0,      // нет подключение по RS
  CON_ON = 1,       // есть подключение по RS
}type_statuc_port_t;

/*Тип ссылки на тестовый вывод*/
typedef struct 
{
  uint32_t      test_pin;         /* номер вывода */                    
  GPIO_TypeDef* p_port;  /* указатель на порт вывода */    
}test_pin_link_t;

/* базовая структура PPUART */
typedef struct 
{
  /*=========================================   Аппаратные ресурсы интерфейса UART    ======================================*/           
  USART_TypeDef *               base_rs_port;                   /* порт UART                                                */
  uint8_t                       URT_GPIO_AF;                    /*                                                          */
  uint32_t                      URT_RCC_APB_Periph;             /*                                                          */ 
  void                          (*RCC_URT_ClockCmd)(uint32_t RCC_APB2Periph, FunctionalState NewState);                 
  IRQn_Type                     URT_IRQn;                       /* прерывание UART                                          */   
  /*========================================================================================================================*/            
  uint32_t                      URT_RX_Pin;                     /*   ввод RX UART                                           */
  GPIO_TypeDef*                 URT_RX_PORT;                                                                              
  uint32_t                      URT_RX_CLK_GPIO;                                                                          
  uint8_t                       URT_RX_PinSource;                                                                         
  /*========================================================================================================================*/            
  uint32_t                      URT_TX_Pin;                     /*  вывод TX UART                                           */
  GPIO_TypeDef*                 URT_TX_PORT;                                                                              
  uint32_t                      URT_TX_CLK_GPIO;                                                                          
  uint8_t                       URT_TX_PinSource;                                                                          
  /*========================================================================================================================*/
  
  /*=========================================   Аппаратные ресурсы вводов - выводов   ======================================*/            
  uint32_t                      LED_TX_Pin;                     /* вывод светодиода передачи                                */ 
  GPIO_TypeDef*                 LED_TX_PORTx;                   /* указатель на базовый адреc порта вывода                  */ 
  uint32_t                      LED_TX_CLK_GPIO;                /* включение тактирования вывода                            */   
  /*========================================================================================================================*/ 
  uint32_t                      LED_RX_Pin;                     /* вывод светодиода приема                                  */ 
  GPIO_TypeDef*                 LED_RX_PORTx;                   /* указатель на базовый адреc порта вывода                  */ 
  uint32_t                      LED_RX_CLK_GPIO;                /* включение тактирования вывода                            */   
  /*========================================================================================================================*/
  uint32_t                      DE_RE_Pin;                      /* вывод переключения PHY  прием /передача                  */ 
  GPIO_TypeDef*                 DE_RE_PORTx;                    /* указатель на базовый адреc порта                         */ 
  uint32_t                      DE_RE_CLK_GPIO;                 /* включение тактирования                                   */ 
  bool                          DE_RE_Inversion_Flag;           /* Флаг инвертирования вывода                               */   
  /*========================================================================================================================*/   
  uint32_t                      RE_Pin;                         /* вывод переключения PHY  прием                            */ 
  GPIO_TypeDef*                 RE_PORTx;                       /* указатель на базовый адреc порта                         */ 
  uint32_t                      RE_CLK_GPIO;                    /* включение тактирования                                   */   
  bool                          RE_Inversion_Flag;              /* Флаг инвертирования вывода                               */   
  /*========================================================================================================================*/    
  uint32_t                      POL_RX_Pin;                     /* вывод установка полярности по приему                     */ 
  GPIO_TypeDef*                 POL_RX_PORTx;                   /* указатель на базовый адреc порта                         */ 
  uint32_t                      POL_RX_CLK_GPIO;                /* включение тактирования                                  */   
  /*========================================================================================================================*/     
  uint32_t                      POL_TX_Pin;                     /* вывод установка полярности по передачи                   */ 
  GPIO_TypeDef*                 POL_TX_PORTx;                   /* указатель на базовый адреc порта                         */ 
  uint32_t                      POL_TX_CLK_GPIO;                /* включение тактирования                                   */   
  /*========================================================================================================================*/  
  uint32_t                      EN_RS_PHY_Pin;                  /* вывод включения питания порта RS                         */ 
  GPIO_TypeDef*                 EN_RS_PHY_PORTx;                /* указатель на базовый адреc порта                         */ 
  uint32_t                      EN_RS_PHY_CLK_GPIO;             /* включение тактирования                                   */   
  /*========================================================================================================================*/ 
  /*========================================================================================================================*/     
  uint32_t                      MODE_Pin;                       /* ввод установки режима работы RS485/RS422                 */ 
  GPIO_TypeDef*                 MODE_PORTx;                     /* указатель на базовый адреc порта                         */ 
  uint32_t                      MODE_CLK_GPIO;                  /* включение тактирования                                   */   
  /*========================================================================================================================*/   
#if TEST_PIN_RS_ENABLE
  /*========================================= указатели на тестовые выводы для отладки =====================================*/            
  test_pin_link_t               ArrTestPin[8];             
#endif  
  /*===================================== Аппаратный таймер для отсчета коротких интервалов ================================*/ 
  TIM_TypeDef*                  base_rs_timer;                  /* Таймер UART                                              */
  IRQn_Type                     TIM_IRQn;                       /* прерывание таймера для UART                              */ 
  uint32_t                      TIM_RCC_APB_Periph;             /*                                                          */ 
  void                          (*RCC_TIM_ClockCmd)(uint32_t RCC_APB2Periph, FunctionalState NewState);                   
  uint32_t                      TIM_clock;                  
  /*========================================================================================================================*/    
  /*================================== Переменная для вычисления констант временных интервалов =============================*/
  float time_one_tic;
  float temp_time_var;    
  /*========================================================================================================================*/
  /*=========================================== Переменная настроек пользователя ===========================================*/  
  uint32_t           baudrate;                                  /* Установка скорости                                       */
  type_set_connect_t set_rs_type;                               /* Установка режима работы                                  */
  uint8_t            n_StopBits;                                /* число стоповых бит                                                    */
  uint8_t            mode_Parity_No;                            /* режим контроля четности                                               */
  type_connect_t     rs_type;                                   /* Режим работы порта RS                                    */ 
  uint8_t            marker_mode;                               /* Режим трансляции маркерных пакетов                       */   
  type_hard_mode_t   hard_setting_mode;                         /* Аппаратная установка режима                              */
  /*========================================================================================================================*/ 
  /*==================================== Переменные указателей на програмные таймеры =======================================*/  
  TimerHandle_t      xSoftTimer;                   /*  Програмный таймер периодического уведомления задачи                  */
  TimerHandle_t      xSoftPolarTimer;              /*  Програмный таймер контроля полярности                                */
  TimerHandle_t      xSoftWaitTX;                  /*  Програмный таймер контроля максимальной паузы между передаваемыми пакетами  */ 
  TimerHandle_t      xSoftTimerDiag;               /*  Програмный таймер запроса подсчета статистики                        */   

  TimerHandle_t      xSoftWaitTxEnd;               /*  Програмный таймер ожидания завершения передачи пакета                */ 
  TimerHandle_t      xSoftWaitRxEnd;               /*  Програмный таймер ожидания завершения приема пакета                  */   
  /*========================================================================================================================*/   
  /*========================================================================================================================*/ 
  uint8_t            size_queue_router_rs;         /* Зададим размер очереди маршрутизатор - rs                             */
  uint8_t            size_queue_rs_router;         /* Зададим размер очереди rs - маршрутизатор                             */
  
  port_router_t      set_port_router;              /* структура для инициализации порта роутера для маршрутизации           */
  uint8_t            index_router_port;            /* переменная для указателя на порт роутера для маршрутизации            */
  
  uint32_t           NotifiedValue;                /* Содержимое сообщения полученного задачей                              */
  BaseType_t         IrqRsTaskNotifyWoken;         /* Запрос внеочередного переключения планировщика из прерывания RS       */
  BaseType_t         IrqTimTaskNotifyWoken;        /* Запрос внеочередного переключения планировщика из прерывания Timer    */  
  /*========================================================================================================================*/   
  RS_RX_FST_t        fst_rs_rx;                    /* Cостояние автомата приема данных                                      */
  RS_TX_FST_t        fst_rs_tx;                    /* Cостояние автомата передачи данных                                    */ 
  bool               flag_marker;                  /* Флаг запроса маркера                                                  */
  type_polar_t       flag_polar;                   /* переменная полярности подключения                                     */ 
  uint8_t            status_polar;                 /* статус полярности подключения                                         */   
  
  uint16_t           index_calc_crc;               /* Переменная индекса для подсчета crc                                   */

  /*========================================================================================================================*/ 
  uint8_t            cnt_led_rx;                   /* Счетчик гашения индикации принятого пакета                            */
  uint8_t            cnt_led_tx;                   /* Счетчик гашения индикации переданного пакета                          */  

  /* =========================================== Переменные делителя таймера ============================================== */
  uint16_t              TIM_RS_Prescaler;                 /* Предварительный делитель таймера.                              */
  uint32_t              TIM_RS_Period;                    /* Период таймера.                                                */
  uint16_t              TIM_RS_ClockDivision;             /* Делитель тактирования таймера.                                 */
  /* ======================================= Переменные формирование интервалов =========================================== */
  uint16_t              box_rx_time_box_tx;               /* RS485 ответ не ранее чем через 400 мкс                         */
  uint16_t 		box_tx_time_no_box_rx;            /* RS485 время ожидания ответа 400 байт, не менее 50 мс 	    */			
  uint16_t 		box_tx_min_time_box_tx;           /* RS422 между макетами не менее 30 бод, не менее 100 мкс         */
  uint16_t 		box_tx_max_time_box_tx;           /* RS422 маркер/данные не реже 300 ms                             */
  uint16_t 		box_tx_completion;                /* Завершени отправки данных из буфера 20 бод                     */
  
  uint32_t 		max_soft_time_box_rx_tx;          /* максимальная продолжительность операции приема - передачи      */
                                                          /* пакета с полуторным запасом для програмного таймера FREERTOS   */
  /* ====================================================================================================================== */  
   
  /* ======================================== Буфер приема данных ========================================================= */ 
#if UDP_LOGGER == 1
  union
  {
    logger_data_box_t    damp_log_rx_data;
    struct
    {
      uint8_t            Logger_rx_data_size;                                  /* Размер данных                   */       
      uint8_t            Logger_rx_type_code;                                  /* Тип данных                      */
      uint32_t           Logger_rx_time_cod; 
      union  /* Буфер данных         */
      {
        uint8_t                     damp_data_rx[sizeof(router_box_t)]; /* Буфер приема данных как байтовый массив       */
        router_box_t 	    data_rx; 	                             /* Буфер приема данных                     */
      };
    }; 
  };                            
  uint8_t 		        code_log_rx;                               /* код логирования принятых данных                                                       */
  bool*    		        flag_log_rx;                               /* указатель на флаг включения логирования принятых данных                               */  
#else
  union  /* Буфер данных         */
  {
    uint8_t                     damp_data_rx[sizeof(router_box_t)]; /* Буфер приема данных как байтовый массив       */
    router_box_t 	    data_rx; 	                             /* Буфер приема данных                     */
  };
#endif  
  
  /* =================================== Переменные управления буфером приема данных ====================================== */ 
  uint8_t 		        cnt_rx_box;                                /* Переменная для хранения состояния счетчика неприрывности принятых пакетов             */
  uint8_t 		        flag_start_cnt_rx_box;                     /* Переменная инициализации переменной состояния счетчика неприрывности принятых пакетов */ 
  uint16_t 		        cnt_data_rx;	                           /* счетчик принятых данных                       */
  /* ====================================================================================================================== */ 
  
  /* ======================================== Буфер передачи данных ======================================================= */
#if UDP_LOGGER == 1 
  union
  {
    logger_data_box_t    damp_log_tx_data;
    struct
    {
      uint8_t            Logger_tx_data_size;                                  /* Размер данных                   */       
      uint8_t            Logger_tx_type_code;                                  /* Тип данных                      */
      uint32_t           Logger_tx_time_cod; 
      
      union  /* Буфер данных         */
      {
        uint8_t                     damp_data_tx[sizeof(router_box_t)];/* Буфер приема данных как байтовый массив       */
        router_box_t 	    data_tx; 	                            /* Буфер передачи данных                         */
      };
    }; 
  };  
  uint8_t 		        code_log_tx;                               /* код логирования переданных данных                                                     */ 
  bool*    		        flag_log_tx;                               /* указатель на флаг включения логирования переданных данных                             */  
#else
  union  /* Буфер данных         */
  {
    uint8_t                     damp_data_tx[sizeof(router_box_t)];/* Буфер приема данных как байтовый массив       */
    router_box_t 	        data_tx; 	                            /* Буфер передачи данных                         */
  };
#endif  
  
  /* =================================== Переменные управления буфером приема данных ====================================== */
  uint8_t 		        contic_tx_box;                             /* Переменная для хранения состояния счетчика неприрывности передаваемых в роутер пакетов*/ 
  uint8_t 		        cnt_tx_box;                                /* Переменная для хранения состояния счетчика неприрывности передаваемых в rs пакетов    */
  uint16_t 		        len_data_tx;	                           /* длинна передаваемых данных		    */	
  uint16_t 		        cnt_data_tx;	                           /* счетчик переданных данных                     */
  /* ====================================================================================================================== */ 
  
  /* ===================================== Буфер пакета диагностики ==================================================== */    
  union
  {
    uint8_t                     damp_data_tx_diag[sizeof(resp_uart_diag_v2_t)]; /* Буфер данных диагностики как байтовый массив    */
    resp_uart_diag_v2_t 	data_tx_diag; 	                             /* Буфер данных диагностики                        */
  }; 
  /* ================================== Переменные статистики =========================================================  */
  uint16_t 		phy_addr_near;                    /*  Физический адрес ВРМ к которому подключен                  */ 

  type_statuc_port_t    status_port;                      /*  Статус работы порта                                        */  
  
  uint8_t 		maska_router_port;                /* маска порта данных                                          */ 
    
  uint32_t 		cnt_err_crc;                      /*  Счётчик ошибок CRC по приёму                               */
  uint32_t 		cnt_err_polar;                    /*  Счётчик поиска полярности, увеличивается, если произошёл   */
                                                          /*  разрыв связи и начался процесс поиска полярности           */
  uint8_t 		load_corrent;                     /* % загрузки — текущий  (за время *)                          */
  uint8_t 		load_max;                         /* % загрузки — максимальный  (за время *)                     */
  
  uint32_t 		cnt_box_tx;	                  /* счетчик переданных пакетов                                  */
  uint32_t 		cnt_box_rx;	                  /* счетчик принятых пакетов                                    */  
  /* =============================== вспомогательные переменные статистики ============================================= */
  uint8_t               cnt_interval;                     /* счетчик малых интервалов                                    */
                                                                                                                         
  uint32_t 		cnt_byte_tx_little;	          /* счетчик переданных байт за малый интервал                   */
  uint8_t 		load_corrent_little_tx;           /*% загрузки — текущий за малый интервал                       */
  uint8_t 		load_max_little_tx;               /*% загрузки — максимальный за малый интервал                  */
  uint16_t 		load_average_corrent_little_tx;   /*% загрузки — средний за интервал                             */
                                                                                                                         
  uint32_t 		cnt_byte_rx_little;	          /* счетчик принятых байт за малый интервал                     */
  uint8_t 		load_corrent_little_rx;           /*% загрузки — текущий  за малый интервал                      */
  uint8_t 		load_max_little_rx;               /*% загрузки — максимальный за малый интервал                  */
  uint16_t 		load_average_corrent_little_rx;   /*% загрузки — средний за интервал                             */
  
  float                 MaxDataTxRxValue;                 /* Максимальный объем данных за за малый интервал              */
  /* =================================================================================================================== */  

  BaseType_t            RSxResult;                        /* Вспомогательные переменные для отработки событий из прерывания RS */
  uint8_t               status_rs_box;                    /* Определяем статус принятого пакет                           */
  bool                  flag_rx_good_box;                 /* Флаг получения корректного пакета                           */
                        
  QueueHandle_t         xQueueCoreCMD;                    /* Открытие очереди для приема MAX_SIZE_QUEUE_CNTRL_CMD комманд*/
  cntrl_cmd_t           data_core_rx_cmd;                 /* Буфер приема данных комманды                                */
  cntrl_cmd_t           data_core_tx_cmd;                 /* Буфер подготовки для передачи данных комманды               */
  
  const char * pcName;                                    /* текстовое имя задачи (для удобства отладки)                 */
  
}RS_struct_t;

#if TEST_PIN_RS_ENABLE
/* описание функций для работы с тестовыми выводами */
 #define HiTP(j,k)     if (((j->ArrTestPin[k]).p_port) != NULL) ((j->ArrTestPin[k]).p_port)->BSRRL = (j->ArrTestPin[k]).test_pin   
 #define LoTP(j,k)     if (((j->ArrTestPin[k]).p_port) != NULL) ((j->ArrTestPin[k]).p_port)->BSRRH = (j->ArrTestPin[k]).test_pin  
 #define TgTP(j,k)     if (((j->ArrTestPin[k]).p_port) != NULL) ((j->ArrTestPin[k]).p_port)->ODR ^=   (j->ArrTestPin[k]).test_pin 
#else
 #define HiTP(j,k)
 #define LoTP(j,k)
 #define TgTP(j,k)
#endif
/* Exported types ------------------------------------------------------------*/

/**
  * @brief  Задача для контроля RS_UART
  * @param  pvParameters not used
  * @retval None
  */
void RS_Control_Task(void * pvParameters);

/**
  * @brief Функция формирования данных статистики.
  * @param router_box_t *rs_box указатель на тестируемый пакет
  * @param RS_struct_t* rs_port_box указатель на структуру
  * @retval bool - true отправить пакет в мультиплексор 
  *                false отбросить
  */ 
bool calc_statistic_box(router_box_t *rs_box, RS_struct_t* rs_port_box );

/**
  * @brief Функция запуска передачи пакета.
  * @param RS_struct_t* rs_port_box указатель на структуру
  * @retval none 
  */
void start_tx_box( RS_struct_t* rs_port_box );

/**
  * @brief Функция обновления данных для диагностики за малый интервал  
  * @param  RS_struct_t* rs_port_box - указатель на структуру контроля UART
  * @retval None
  */
void UpdateLitteDiagUART(RS_struct_t* rs_port_box);

/**
  * @brief Функция установки режима работы.
  * @param RS_struct_t* PortRS указатель на структуру
  * @retval none
  */ 
void InitModeWork( RS_struct_t* PortRS );

/**
  * @brief Функция смены полярности приемника.
  * @param RS_struct_t* rs_port_box указатель на структуру
  * @retval none 
  */
void Reversal_Polar_RX( RS_struct_t* rs_port_box );

#endif 
#endif /* __UART_CONTROL_H */
/******************* (C)  COPYRIGHT 2015 DataExpress  *****END OF FILE****/
